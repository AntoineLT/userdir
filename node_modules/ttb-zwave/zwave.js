/*
	Copyright (c) 2015 Digital Airways (www.DigitalAirways.com)
	This work is free. You can redistribute it and/or modify it under the
	terms of the "Do What The Fuck You Want To" Public License, Version 2,
	as published by Sam Hocevar. 
	See http://www.wtfpl.net for more details.
*/

module.exports = function ( RED ) {
	"use strict";

    // Requires
    var fs = require('fs');
    var isUtf8 = require(process.env.NODE_RED_HOME+'/node_modules/is-utf8');
	var openZwave = require('openzwave-shared');
	var bus = require('./resources/bus.js');
	var configuration = require('./resources/config.js');
    var mqtt = require(process.env.NODE_RED_HOME+"/nodes/core/io/lib/mqttConnectionPool");
    
    // Initialize the 'zwave' variable
    var zwave = {};
    
	function zwaveMqtt(config) {
        RED.nodes.createNode(this,config);
        this.broker = config.broker;
        this.port = config.port;
        this.clientid = config.clientid;
        if (this.credentials) {
            this.username = this.credentials.user;
            this.password = this.credentials.password;
        }
    }
	RED.nodes.registerType("zwave-broker",zwaveMqtt,{
        credentials: {
            user: {type:"text"},
            password: {type: "password"}
        }
    });
	
	function zwaveNode(config) {
		RED.nodes.createNode(this,config);
        this.topic = config.topic;
        this.broker = config.broker;
        this.brokerConfig = RED.nodes.getNode(this.broker);
		var node = this;
		if(typeof this.brokerConfig != "undefined"){
			// Initialize the MQTT connection
			var clientMQTT = mqtt.get(this.brokerConfig.broker,
                                      this.brokerConfig.port,
                                      this.brokerConfig.clientid,
                                      this.brokerConfig.username,
                                      this.brokerConfig.password);
			clientMQTT.on("connectionlost",function() {
				node.warn("Connection to MQTT lost");
                node.status({fill:"red",shape:"ring",text:"node-red:common.status.disconnected"});
			});
			clientMQTT.on("connect",function() {
				node.log("Connection to MQTT established");
                node.status({fill:"green",shape:"dot",text:"node-red:common.status.connected"});
			});
			clientMQTT.connect();
			
			// Initialize the Zwave connector
			zwave = new openZwave({
				SaveConfiguration:      configuration.saveconfig,
				Logging:                configuration.logging, 
				ConsoleOutput:          configuration.consoleoutput,
				SuppressValueRefresh:   configuration.suppressrefresh
			});
            
            zwave.lastY=40;
            
            // Handler relative variables definition
			var nodes = [];
            
			// When the driver is ready
            zwave.on('driver ready', function(homeid) {
                if(isNotInFlow("zwave", null, null)) {
                    RED.nodes.addNodeToClients({
                        "type": "tab",
                        "id": "zwave",
                        "label": "Z-wave"
                    });
                }
				node.log('Scanning homeid=0x'+homeid.toString(16)+'...');
			});
			
			// When the driver failed to start
            zwave.on('driver failed', function() {
				node.warn('Failed to start Z-wave controller driver');
			});

			// When a node is discovered and added
            zwave.on('node added', function(nodeid) {
                nodes[nodeid] = {
					manufacturer : '',
					manufacturerid : '',
					product : '',
					producttype : '',
					productid : '',
					type : '',
					name : '',
					loc : '',
					classes : {},
					ready : false,
				};
			});
			
			// When a new value is added
            zwave.on('value added', function(nodeid, comclass, value) {
                // Create a new instance of Zwave In
                if(nodeid !== 1 && value.label !== "" && isNotInFlow(nodeid, comclass, value)){
                    /*
                    { type: 'decimal',
                      genre: 'user',
                      instance: 1,
                      index: 1,
                      label: 'Temperature',
                      units: '',
                      read_only: true,
                      write_only: false,
                      min: 0,
                      max: 0,
                      value: 0 }
                    { type: 'decimal',
                      genre: 'user',
                      instance: 1,
                      index: 3,
                      label: 'Luminance',
                      units: '',
                      read_only: true,
                      write_only: false,
                      min: 0,
                      max: 0,
                      value: 0 }
                    */
                    if(comclassToShow(comclass)) {
                        RED.nodes.addNodeToClients({
                            "id": "zwave-in-"+nodeid+"-"+comclass+":"+value.index,
                            "type": "zwave-in",
                            "name": "Node"+nodeid+" : "+value.label,
                            "topic": config.topic +  nodeid + "/" + comclass + "/" + value.index + "/",
                            "nodeid": nodeid,
                            "broker": config.broker,
                            "x": 200,
                            "y": zwave.lastY,
                            "z": "zwave"
                        });
                        zwave.lastY+=60;
                    }
                }
                
                
				if (!nodes[nodeid].classes[comclass]) {
					nodes[nodeid].classes[comclass] = {};
				}
				nodes[nodeid].classes[comclass][value.index] = value;
			});

			// When a value changed
            zwave.on('value changed', function(nodeid, comclass, value) {
				// Broadcast the event with the comclass
				bus.emit(comclass, nodeid, value);
				nodes[nodeid].classes[comclass][value.index] = value;
				
				// initialize mqtt params
				var msg = {};
				msg.qos = 1;
				msg.retain = false;
				msg.topic = config.topic +  nodeid + "/" + comclass + "/" + value.index + "/";
				msg.payload = value.value;
				if(typeof clientMQTT != "undefined")
					clientMQTT.publish(msg);
			});

			// When a value is removed
            zwave.on('value removed', function(nodeid, comclass, index) {
				if (nodes[nodeid].classes[comclass] && 
						nodes[nodeid].classes[comclass][index]){
					delete nodes[nodeid].classes[comclass][index];
				}
			});

			// When a node is ready
            zwave.on('node ready', function(nodeid, nodeinfo) {
				nodes[nodeid].manufacturer = nodeinfo.manufacturer;
				nodes[nodeid].manufacturerid = nodeinfo.manufacturerid;
				nodes[nodeid].product = nodeinfo.product;
				nodes[nodeid].producttype = nodeinfo.producttype;
				nodes[nodeid].productid = nodeinfo.productid;
				nodes[nodeid].type = nodeinfo.type;
				nodes[nodeid].name = nodeinfo.name;
				nodes[nodeid].loc = nodeinfo.loc;
				nodes[nodeid].ready = true;
                
                node.log('node'+nodeid+': '
                         +((nodeinfo.manufacturer) ? nodeinfo.manufacturer : ' id=' + nodeinfo.manufacturerid)+', '
                         +((nodeinfo.product) ? nodeinfo.product : 'product=' + nodeinfo.productid + ', type=' + nodeinfo.producttype));
                                
				node.log('node'+nodeid+': name="'+nodeinfo.name+'", type="'+nodeinfo.type+'", location="'+nodeinfo.loc+'"');// type written
				
				for (var comclass in nodes[nodeid].classes) {
					switch (comclass) {
					case 0x25: // COMMAND_CLASS_SWITCH_BINARY
					case 0x26: // COMMAND_CLASS_SWITCH_MULTILEVEL
						zwave.enablePoll(nodeid, comclass);
						break;
					}
				}
			});

			// When a notification is received
            zwave.on('notification', function(nodeid, notif) {
				switch (notif) {
				case 0:
					node.log('node'+nodeid+': message complete');
					break;
				case 1:
					node.log('node'+nodeid+': timeout');
					break;
				case 2:
					node.log('node'+nodeid+': nop');
					break;
				case 3:
					node.log('node'+nodeid+': node awake');
					break;
				case 4:
					node.log('node'+nodeid+': node sleep');
					break;
				case 5:
					node.log('node'+nodeid+': node dead');
					break;
				case 6:
					node.log('node'+nodeid+': node alive');
					break;
                default:
                    node.log('node'+nodeid+': unhandled notification');
                    break;
				}
			});

			// When the network scan is complete
			zwave.on('scan complete', function() {
				node.log('Z-Wave network scan complete!');
			});

			// Zwave connect
			zwave.connect(configuration.device);
            
            // When a Deploy is clicked
			this.on('close', function() {
                if (zwave) {
                    zwave.disconnect(configuration.device);
                }
				if (clientMQTT) {
					clientMQTT.disconnect();
				}
			});
		}
		else{
			node.error("No broker config");
		}
	}
	RED.nodes.registerType("zwave", zwaveNode);
    
    function MQTTInNode(config) {
        RED.nodes.createNode(this,config);
        this.topic = config.topic;
        this.broker = config.broker;
        this.brokerConfig = RED.nodes.getNode(this.broker);
        if (this.brokerConfig) {
            this.status({fill:"red",shape:"ring",text:"node-red:common.status.disconnected"});
            this.client = mqtt.get(this.brokerConfig.broker,
                                   this.brokerConfig.port,
                                   this.brokerConfig.clientid,
                                   this.brokerConfig.username,
                                   this.brokerConfig.password);
            var node = this;
            if (this.topic) {
                this.client.subscribe(this.topic,2,function(topic,payload,qos,retain) {
                    if (isUtf8(payload)) { payload = payload.toString(); }
                    switch(payload){
                        case "TRUE":
                        case "true":
                            payload = 1;
                            break;
                            
                        case "FALSE":
                        case "false":
                            payload = 0;
                            break;
                            
                        default:
                            break;
                    }
                    var msg = {topic:topic,payload:payload,qos:qos,retain:retain};
                    if ((node.brokerConfig.broker === "localhost")||(node.brokerConfig.broker === "127.0.0.1")) {
                        msg._topic = topic;
                    }
                    switch(msg.payload){ // in order to work with intents
                        case "true":
                            msg.intents = 1;
                            break;
                        case "false":
                            msg.intents = 0;
                            break;
                        default:
                            if(isNaN(msg.payload)) {
                                msg.value = msg.payload;
                                break;
                            } else {
                                msg.value = parseInt(msg.payload);
                                break;
                            }
                    }
                    node.send(msg);
                }, this.id);
                this.client.on("connectionlost",function() {
                    node.status({fill:"red",shape:"ring",text:"node-red:common.status.disconnected"});
                });
                this.client.on("connect",function() {
                    node.status({fill:"green",shape:"dot",text:"node-red:common.status.connected"});
                });
                if (this.client.isConnected()) {
                    node.status({fill:"green",shape:"dot",text:"node-red:common.status.connected"});
                } else {
                    this.client.connect();
                }
            }
            else {
                this.error(RED._("node-red:mqtt.errors.not-defined"));
            }
        } else {
            this.error(RED._("node-red:mqtt.errors.missing-config"));
        }
        this.on('close', function() {
            if (this.client) {
                this.client.unsubscribe(this.topic,this.id);
                this.client.disconnect();
            }
        });
    }
    RED.nodes.registerType("zwave-in", MQTTInNode);
    
    function zwaveOut(config) {
        RED.nodes.createNode(this,config);
        this.method = config.method;
        this.nodeid = config.nodeid;
        this.level  = config.level;
        this.class  = config.class;
        this.index  = config.index;
        this.value  = config.value;
        
        this.on('input', function(msg) {
            // If a msg is in input
            if(msg.method !== undefined && msg.method !== "") this.method = msg.method;
            if(msg.level !== undefined && msg.level !== "")   this.level = msg.level;
            if(msg.class !== undefined && msg.class !== "")   this.class = msg.class;
            if(msg.index !== undefined && msg.index !== "")   this.index = msg.index;
            if(msg.value !== undefined && msg.value !== "")   this.value = msg.value;
            if(msg.nodeid !== undefined && msg.nodeid !== "") this.nodeid = msg.nodeid;
            
            this.nodeid = parseInt(this.nodeid);
            this.class  = parseInt(this.class);
            this.index  = parseInt(this.index);
            this.level  = parseInt(this.level);
            
            if (msg.intent || msg.intent == 0) {
                if (msg.intent == 0) { // open
                    zwave.setValue(this.nodeid, 37, 1, 0, false);
                } else if (msg.intent == 1) { // close
                    zwave.setValue(this.nodeid, 37, 1, 0, true);
                } 
            } else {
                switch(this.method){
                    case "setlevel":
                        zwave.setValue(this.nodeid, 38, 1, 0, this.level);
                        break;
                    case "switchon":
                        zwave.setValue(this.nodeid, 37, 1, 0, true);
                        break;
                    case "switchoff":
                        zwave.setValue(this.nodeid, 37, 1, 0, false);
                        break;
                    case "setvalue":
                        if(this.class === 37) {
                            this.value = (this.value !== '0');
                        } else {
                            this.value = parseInt(this.value);
                        }
                        zwave.setValue(this.nodeid, this.class, 1, this.index, this.value);
                        break;
                }
            }
        });
        
    }
    RED.nodes.registerType("zwave-out", zwaveOut);
    
    // Function to check if the instance is already in flows file
    function isNotInFlow(nodeid, comclass, value) {
        var test = true;
        var filename = "/root/userdir/flows.json";
        var flows = JSON.parse(fs.readFileSync(filename, 'utf8'));
        for(var i = 0; i < flows.length; i++) {
            if(comclass !== null && value !== null) {
                var node = "zwave-in-"+nodeid+"-"+comclass+":"+value.index;
            } else {
                var node = nodeid;
            }
            if(flows[i].id === node){
                test = false;
            }
        }
        return test;
    }
    
    // Funtion to avoid some unused instance during the self-generation
    function comclassToShow(comclass) {
        var test = false;
        if (comclass !== 50 && comclass !== 94 && comclass !== 112 && comclass !== 115 && comclass !== 132 && comclass !== 134) {
            test = true;
        }
        return test;
    }
}